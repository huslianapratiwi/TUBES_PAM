{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport { Platform } from '@unimodules/core';\nimport { getAssetByID } from \"./AssetRegistry\";\nimport * as AssetSources from \"./AssetSources\";\nimport * as AssetUris from \"./AssetUris\";\nimport { getEmbeddedAssetUri } from \"./EmbeddedAssets\";\nimport * as ImageAssets from \"./ImageAssets\";\nimport { downloadAsync as _downloadAsync, IS_MANAGED_ENV } from \"./PlatformUtils\";\nimport resolveAssetSource from \"./resolveAssetSource\";\nexport var Asset = function () {\n  function Asset(_ref) {\n    var name = _ref.name,\n      type = _ref.type,\n      _ref$hash = _ref.hash,\n      hash = _ref$hash === void 0 ? null : _ref$hash,\n      uri = _ref.uri,\n      width = _ref.width,\n      height = _ref.height;\n    _classCallCheck(this, Asset);\n    this.hash = null;\n    this.localUri = null;\n    this.width = null;\n    this.height = null;\n    this.downloading = false;\n    this.downloaded = false;\n    this._downloadCallbacks = [];\n    this.name = name;\n    this.type = type;\n    this.hash = hash;\n    this.uri = uri;\n    if (typeof width === 'number') {\n      this.width = width;\n    }\n    if (typeof height === 'number') {\n      this.height = height;\n    }\n    if (IS_MANAGED_ENV && hash) {\n      this.localUri = getEmbeddedAssetUri(hash, type);\n      if (this.localUri) {\n        this.downloaded = true;\n      }\n    }\n    if (Platform.OS === 'web') {\n      if (!name) {\n        this.name = AssetUris.getFilename(uri);\n      }\n      if (!type) {\n        this.type = AssetUris.getFileExtension(uri);\n      }\n    }\n  }\n  _createClass(Asset, [{\n    key: \"downloadAsync\",\n    value: function downloadAsync() {\n      var _this = this;\n      var _await$ImageAssets$ge, width, height, name;\n      return _regeneratorRuntime.async(function downloadAsync$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!this.downloaded) {\n                _context.next = 2;\n                break;\n              }\n              return _context.abrupt(\"return\");\n            case 2:\n              if (!this.downloading) {\n                _context.next = 6;\n                break;\n              }\n              _context.next = 5;\n              return _regeneratorRuntime.awrap(new Promise(function (resolve, reject) {\n                _this._downloadCallbacks.push({\n                  resolve: resolve,\n                  reject: reject\n                });\n              }));\n            case 5:\n              return _context.abrupt(\"return\");\n            case 6:\n              this.downloading = true;\n              _context.prev = 7;\n              if (!(Platform.OS === 'web')) {\n                _context.next = 22;\n                break;\n              }\n              if (!ImageAssets.isImageType(this.type)) {\n                _context.next = 21;\n                break;\n              }\n              _context.next = 12;\n              return _regeneratorRuntime.awrap(ImageAssets.getImageInfoAsync(this.uri));\n            case 12:\n              _await$ImageAssets$ge = _context.sent;\n              width = _await$ImageAssets$ge.width;\n              height = _await$ImageAssets$ge.height;\n              name = _await$ImageAssets$ge.name;\n              this.width = width;\n              this.height = height;\n              this.name = name;\n              _context.next = 22;\n              break;\n            case 21:\n              this.name = AssetUris.getFilename(this.uri);\n            case 22:\n              _context.next = 24;\n              return _regeneratorRuntime.awrap(_downloadAsync(this.uri, this.hash, this.type, this.name));\n            case 24:\n              this.localUri = _context.sent;\n              this.downloaded = true;\n              this._downloadCallbacks.forEach(function (_ref2) {\n                var resolve = _ref2.resolve;\n                return resolve();\n              });\n              _context.next = 33;\n              break;\n            case 29:\n              _context.prev = 29;\n              _context.t0 = _context[\"catch\"](7);\n              this._downloadCallbacks.forEach(function (_ref3) {\n                var reject = _ref3.reject;\n                return reject(_context.t0);\n              });\n              throw _context.t0;\n            case 33:\n              _context.prev = 33;\n              this.downloading = false;\n              this._downloadCallbacks = [];\n              return _context.finish(33);\n            case 37:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, null, this, [[7, 29, 33, 37]], Promise);\n    }\n  }], [{\n    key: \"loadAsync\",\n    value: function loadAsync(moduleId) {\n      var moduleIds = Array.isArray(moduleId) ? moduleId : [moduleId];\n      return Promise.all(moduleIds.map(function (moduleId) {\n        return Asset.fromModule(moduleId).downloadAsync();\n      }));\n    }\n  }, {\n    key: \"fromModule\",\n    value: function fromModule(virtualAssetModule) {\n      if (typeof virtualAssetModule === 'string') {\n        return Asset.fromURI(virtualAssetModule);\n      }\n      var meta = getAssetByID(virtualAssetModule);\n      if (!meta) {\n        throw new Error(\"Module \\\"\" + virtualAssetModule + \"\\\" is missing from the asset registry\");\n      }\n      if (!IS_MANAGED_ENV) {\n        var _resolveAssetSource = resolveAssetSource(virtualAssetModule),\n          uri = _resolveAssetSource.uri;\n        var asset = new Asset({\n          name: meta.name,\n          type: meta.type,\n          hash: meta.hash,\n          uri: uri,\n          width: meta.width,\n          height: meta.height\n        });\n        if (Platform.OS === 'android' && !uri.includes(':') && (meta.width || meta.height)) {\n          asset.localUri = asset.uri;\n          asset.downloaded = true;\n        }\n        Asset.byHash[meta.hash] = asset;\n        return asset;\n      }\n      return Asset.fromMetadata(meta);\n    }\n  }, {\n    key: \"fromMetadata\",\n    value: function fromMetadata(meta) {\n      var metaHash = meta.hash;\n      if (Asset.byHash[metaHash]) {\n        return Asset.byHash[metaHash];\n      } else if (!IS_MANAGED_ENV && !Asset.byHash[metaHash]) {\n        throw new Error('Assets must be initialized with Asset.fromModule');\n      }\n      var _AssetSources$selectA = AssetSources.selectAssetSource(meta),\n        uri = _AssetSources$selectA.uri,\n        hash = _AssetSources$selectA.hash;\n      var asset = new Asset({\n        name: meta.name,\n        type: meta.type,\n        hash: hash,\n        uri: uri,\n        width: meta.width,\n        height: meta.height\n      });\n      Asset.byHash[metaHash] = asset;\n      return asset;\n    }\n  }, {\n    key: \"fromURI\",\n    value: function fromURI(uri) {\n      if (Asset.byUri[uri]) {\n        return Asset.byUri[uri];\n      }\n      var type = '';\n      if (uri.indexOf(';base64') > -1) {\n        type = uri.split(';')[0].split('/')[1];\n      } else {\n        var extension = AssetUris.getFileExtension(uri);\n        type = extension.startsWith('.') ? extension.substring(1) : extension;\n      }\n      var asset = new Asset({\n        name: '',\n        type: type,\n        hash: null,\n        uri: uri\n      });\n      Asset.byUri[uri] = asset;\n      return asset;\n    }\n  }]);\n  return Asset;\n}();\nAsset.byHash = {};\nAsset.byUri = {};","map":{"version":3,"mappings":";;;AAAA,SAASA,QAAQ,QAAQ,kBAAkB;AAE3C,SAASC,YAAY;AACrB,OAAO,KAAKC,YAAY;AACxB,OAAO,KAAKC,SAAS;AACrB,SAASC,mBAAmB;AAC5B,OAAO,KAAKC,WAAW;AACvB,SAASC,aAAa,IAAbA,cAAa,EAAEC,cAAc;AACtC,OAAOC,kBAAkB;AAkBzB,WAAaC,KAAK;EAehB,qBAA4E;IAAA,IAA9DC,IAAI,QAAJA,IAAI;MAAEC,IAAI,QAAJA,IAAI;MAAA,iBAAEC,IAAI;MAAJA,IAAI,0BAAG,IAAI;MAAEC,GAAG,QAAHA,GAAG;MAAEC,KAAK,QAALA,KAAK;MAAEC,MAAM,QAANA,MAAM;IAAA;IATzD,SAAI,GAAkB,IAAI;IAE1B,aAAQ,GAAkB,IAAI;IAC9B,UAAK,GAAkB,IAAI;IAC3B,WAAM,GAAkB,IAAI;IAC5B,gBAAW,GAAY,KAAK;IAC5B,eAAU,GAAY,KAAK;IAC3B,uBAAkB,GAA+B,EAAE;IAGjD,IAAI,CAACL,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACC,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACC,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACC,GAAG,GAAGA,GAAG;IAEd,IAAI,OAAOC,KAAK,KAAK,QAAQ,EAAE;MAC7B,IAAI,CAACA,KAAK,GAAGA,KAAK;;IAEpB,IAAI,OAAOC,MAAM,KAAK,QAAQ,EAAE;MAC9B,IAAI,CAACA,MAAM,GAAGA,MAAM;;IAItB,IAAIR,cAAc,IAAIK,IAAI,EAAE;MAC1B,IAAI,CAACI,QAAQ,GAAGZ,mBAAmB,CAACQ,IAAI,EAAED,IAAI,CAAC;MAC/C,IAAI,IAAI,CAACK,QAAQ,EAAE;QACjB,IAAI,CAACC,UAAU,GAAG,IAAI;;;IAG1B,IAAIjB,QAAQ,CAACkB,EAAE,KAAK,KAAK,EAAE;MACzB,IAAI,CAACR,IAAI,EAAE;QACT,IAAI,CAACA,IAAI,GAAGP,SAAS,CAACgB,WAAW,CAACN,GAAG,CAAC;;MAExC,IAAI,CAACF,IAAI,EAAE;QACT,IAAI,CAACA,IAAI,GAAGR,SAAS,CAACiB,gBAAgB,CAACP,GAAG,CAAC;;;EAGjD;EAAC;IAAA;IAAA;MAAA;MAAA;MAAA;QAAA;UAAA;YAAA;cAAA,KAgGK,IAAI,CAACI,UAAU;gBAAA;gBAAA;cAAA;cAAA;YAAA;cAAA,KAGf,IAAI,CAACI,WAAW;gBAAA;gBAAA;cAAA;cAAA;cAAA,iCACZ,IAAIC,OAAO,CAAC,UAACC,OAAO,EAAEC,MAAM,EAAI;gBACpC,KAAI,CAACC,kBAAkB,CAACC,IAAI,CAAC;kBAAEH,OAAO,EAAPA,OAAO;kBAAEC,MAAM,EAANA;gBAAM,CAAE,CAAC;cACnD,CAAC,CAAC;YAAA;cAAA;YAAA;cAGJ,IAAI,CAACH,WAAW,GAAG,IAAI;cAAC;cAAA,MAGlBrB,QAAQ,CAACkB,EAAE,KAAK,KAAK;gBAAA;gBAAA;cAAA;cAAA,KACnBb,WAAW,CAACsB,WAAW,CAAC,IAAI,CAAChB,IAAI,CAAC;gBAAA;gBAAA;cAAA;cAAA;cAAA,iCACEN,WAAW,CAACuB,iBAAiB,CAAC,IAAI,CAACf,GAAG,CAAC;YAAA;cAAA;cAArEC,KAAK,yBAALA,KAAK;cAAEC,MAAM,yBAANA,MAAM;cAAEL,IAAI,yBAAJA,IAAI;cAC3B,IAAI,CAACI,KAAK,GAAGA,KAAK;cAClB,IAAI,CAACC,MAAM,GAAGA,MAAM;cACpB,IAAI,CAACL,IAAI,GAAGA,IAAI;cAAC;cAAA;YAAA;cAEjB,IAAI,CAACA,IAAI,GAAGP,SAAS,CAACgB,WAAW,CAAC,IAAI,CAACN,GAAG,CAAC;YAAC;cAAA;cAAA,iCAG1BP,cAAa,CAAC,IAAI,CAACO,GAAG,EAAE,IAAI,CAACD,IAAI,EAAE,IAAI,CAACD,IAAI,EAAE,IAAI,CAACD,IAAI,CAAC;YAAA;cAA9E,IAAI,CAACM,QAAQ;cAEb,IAAI,CAACC,UAAU,GAAG,IAAI;cACtB,IAAI,CAACQ,kBAAkB,CAACI,OAAO,CAAC;gBAAA,IAAGN,OAAO,SAAPA,OAAO;gBAAA,OAAOA,OAAO,EAAE;cAAA,EAAC;cAAC;cAAA;YAAA;cAAA;cAAA;cAE5D,IAAI,CAACE,kBAAkB,CAACI,OAAO,CAAC;gBAAA,IAAGL,MAAM,SAANA,MAAM;gBAAA,OAAOA,MAAM,aAAG;cAAA,EAAC;cAAC;YAAA;cAAA;cAG3D,IAAI,CAACH,WAAW,GAAG,KAAK;cACxB,IAAI,CAACI,kBAAkB,GAAG,EAAE;cAAC;YAAA;YAAA;cAAA;UAAA;QAAA;MAAA;IAAA;EAAA;IAAA;IAAA,0BA7HhBK,QAA2B;MAC1C,IAAMC,SAAS,GAAGC,KAAK,CAACC,OAAO,CAACH,QAAQ,CAAC,GAAGA,QAAQ,GAAG,CAACA,QAAQ,CAAC;MACjE,OAAOR,OAAO,CAACY,GAAG,CAACH,SAAS,CAACI,GAAG,CAAC,kBAAQ;QAAA,OAAI1B,KAAK,CAAC2B,UAAU,CAACN,QAAQ,CAAC,CAACxB,aAAa,EAAE;MAAA,EAAC,CAAC;IAC3F;EAAC;IAAA;IAAA,2BAEiB+B,kBAAmC;MACnD,IAAI,OAAOA,kBAAkB,KAAK,QAAQ,EAAE;QAC1C,OAAO5B,KAAK,CAAC6B,OAAO,CAACD,kBAAkB,CAAC;;MAG1C,IAAME,IAAI,GAAGtC,YAAY,CAACoC,kBAAkB,CAAC;MAC7C,IAAI,CAACE,IAAI,EAAE;QACT,MAAM,IAAIC,KAAK,eAAYH,kBAAkB,2CAAuC;;MAKtF,IAAI,CAAC9B,cAAc,EAAE;QAAA,0BACHC,kBAAkB,CAAC6B,kBAAkB,CAAC;UAA9CxB,GAAG,uBAAHA,GAAG;QACX,IAAM4B,KAAK,GAAG,IAAIhC,KAAK,CAAC;UACtBC,IAAI,EAAE6B,IAAI,CAAC7B,IAAI;UACfC,IAAI,EAAE4B,IAAI,CAAC5B,IAAI;UACfC,IAAI,EAAE2B,IAAI,CAAC3B,IAAI;UACfC,GAAG,EAAHA,GAAG;UACHC,KAAK,EAAEyB,IAAI,CAACzB,KAAK;UACjBC,MAAM,EAAEwB,IAAI,CAACxB;SACd,CAAC;QAMF,IAAIf,QAAQ,CAACkB,EAAE,KAAK,SAAS,IAAI,CAACL,GAAG,CAAC6B,QAAQ,CAAC,GAAG,CAAC,KAAKH,IAAI,CAACzB,KAAK,IAAIyB,IAAI,CAACxB,MAAM,CAAC,EAAE;UAClF0B,KAAK,CAACzB,QAAQ,GAAGyB,KAAK,CAAC5B,GAAG;UAC1B4B,KAAK,CAACxB,UAAU,GAAG,IAAI;;QAGzBR,KAAK,CAACkC,MAAM,CAACJ,IAAI,CAAC3B,IAAI,CAAC,GAAG6B,KAAK;QAC/B,OAAOA,KAAK;;MAGd,OAAOhC,KAAK,CAACmC,YAAY,CAACL,IAAI,CAAC;IACjC;EAAC;IAAA;IAAA,6BAEmBA,IAAmB;MAGrC,IAAMM,QAAQ,GAAGN,IAAI,CAAC3B,IAAI;MAC1B,IAAIH,KAAK,CAACkC,MAAM,CAACE,QAAQ,CAAC,EAAE;QAC1B,OAAOpC,KAAK,CAACkC,MAAM,CAACE,QAAQ,CAAC;OAC9B,MAAM,IAAI,CAACtC,cAAc,IAAI,CAACE,KAAK,CAACkC,MAAM,CAACE,QAAQ,CAAC,EAAE;QACrD,MAAM,IAAIL,KAAK,CAAC,kDAAkD,CAAC;;MACpE,4BAEqBtC,YAAY,CAAC4C,iBAAiB,CAACP,IAAI,CAAC;QAAlD1B,GAAG,yBAAHA,GAAG;QAAED,IAAI,yBAAJA,IAAI;MACjB,IAAM6B,KAAK,GAAG,IAAIhC,KAAK,CAAC;QACtBC,IAAI,EAAE6B,IAAI,CAAC7B,IAAI;QACfC,IAAI,EAAE4B,IAAI,CAAC5B,IAAI;QACfC,IAAI,EAAJA,IAAI;QACJC,GAAG,EAAHA,GAAG;QACHC,KAAK,EAAEyB,IAAI,CAACzB,KAAK;QACjBC,MAAM,EAAEwB,IAAI,CAACxB;OACd,CAAC;MACFN,KAAK,CAACkC,MAAM,CAACE,QAAQ,CAAC,GAAGJ,KAAK;MAC9B,OAAOA,KAAK;IACd;EAAC;IAAA;IAAA,wBAEc5B,GAAW;MACxB,IAAIJ,KAAK,CAACsC,KAAK,CAAClC,GAAG,CAAC,EAAE;QACpB,OAAOJ,KAAK,CAACsC,KAAK,CAAClC,GAAG,CAAC;;MAIzB,IAAIF,IAAI,GAAG,EAAE;MACb,IAAIE,GAAG,CAACmC,OAAO,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,EAAE;QAC/BrC,IAAI,GAAGE,GAAG,CAACoC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAACA,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;OACvC,MAAM;QACL,IAAMC,SAAS,GAAG/C,SAAS,CAACiB,gBAAgB,CAACP,GAAG,CAAC;QACjDF,IAAI,GAAGuC,SAAS,CAACC,UAAU,CAAC,GAAG,CAAC,GAAGD,SAAS,CAACE,SAAS,CAAC,CAAC,CAAC,GAAGF,SAAS;;MAGvE,IAAMT,KAAK,GAAG,IAAIhC,KAAK,CAAC;QACtBC,IAAI,EAAE,EAAE;QACRC,IAAI,EAAJA,IAAI;QACJC,IAAI,EAAE,IAAI;QACVC,GAAG,EAAHA;OACD,CAAC;MAEFJ,KAAK,CAACsC,KAAK,CAAClC,GAAG,CAAC,GAAG4B,KAAK;MAExB,OAAOA,KAAK;IACd;EAAC;EAAA;AAAA;AAvIMhC,YAAM,GAAG,EAAE;AACXA,WAAK,GAAG,EAAE","names":["Platform","getAssetByID","AssetSources","AssetUris","getEmbeddedAssetUri","ImageAssets","downloadAsync","IS_MANAGED_ENV","resolveAssetSource","Asset","name","type","hash","uri","width","height","localUri","downloaded","OS","getFilename","getFileExtension","downloading","Promise","resolve","reject","_downloadCallbacks","push","isImageType","getImageInfoAsync","forEach","moduleId","moduleIds","Array","isArray","all","map","fromModule","virtualAssetModule","fromURI","meta","Error","asset","includes","byHash","fromMetadata","metaHash","selectAssetSource","byUri","indexOf","split","extension","startsWith","substring"],"sourceRoot":"","sources":["../src/Asset.ts"],"sourcesContent":["import { Platform } from '@unimodules/core';\n\nimport { getAssetByID } from './AssetRegistry';\nimport * as AssetSources from './AssetSources';\nimport * as AssetUris from './AssetUris';\nimport { getEmbeddedAssetUri } from './EmbeddedAssets';\nimport * as ImageAssets from './ImageAssets';\nimport { downloadAsync, IS_MANAGED_ENV } from './PlatformUtils';\nimport resolveAssetSource from './resolveAssetSource';\n\ntype AssetDescriptor = {\n  name: string;\n  type: string;\n  hash?: string | null;\n  uri: string;\n  width?: number | null;\n  height?: number | null;\n};\n\ntype DownloadPromiseCallbacks = {\n  resolve: () => void;\n  reject: (error: Error) => void;\n};\n\nexport type AssetMetadata = AssetSources.AssetMetadata;\n\nexport class Asset {\n  static byHash = {};\n  static byUri = {};\n\n  name: string;\n  type: string;\n  hash: string | null = null;\n  uri: string;\n  localUri: string | null = null;\n  width: number | null = null;\n  height: number | null = null;\n  downloading: boolean = false;\n  downloaded: boolean = false;\n  _downloadCallbacks: DownloadPromiseCallbacks[] = [];\n\n  constructor({ name, type, hash = null, uri, width, height }: AssetDescriptor) {\n    this.name = name;\n    this.type = type;\n    this.hash = hash;\n    this.uri = uri;\n\n    if (typeof width === 'number') {\n      this.width = width;\n    }\n    if (typeof height === 'number') {\n      this.height = height;\n    }\n\n    // This only applies to assets that are bundled in Expo standalone apps\n    if (IS_MANAGED_ENV && hash) {\n      this.localUri = getEmbeddedAssetUri(hash, type);\n      if (this.localUri) {\n        this.downloaded = true;\n      }\n    }\n    if (Platform.OS === 'web') {\n      if (!name) {\n        this.name = AssetUris.getFilename(uri);\n      }\n      if (!type) {\n        this.type = AssetUris.getFileExtension(uri);\n      }\n    }\n  }\n\n  static loadAsync(moduleId: number | number[]): Promise<void[]> {\n    const moduleIds = Array.isArray(moduleId) ? moduleId : [moduleId];\n    return Promise.all(moduleIds.map(moduleId => Asset.fromModule(moduleId).downloadAsync()));\n  }\n\n  static fromModule(virtualAssetModule: number | string): Asset {\n    if (typeof virtualAssetModule === 'string') {\n      return Asset.fromURI(virtualAssetModule);\n    }\n\n    const meta = getAssetByID(virtualAssetModule);\n    if (!meta) {\n      throw new Error(`Module \"${virtualAssetModule}\" is missing from the asset registry`);\n    }\n\n    // Outside of the managed env we need the moduleId to initialize the asset\n    // because resolveAssetSource depends on it\n    if (!IS_MANAGED_ENV) {\n      const { uri } = resolveAssetSource(virtualAssetModule);\n      const asset = new Asset({\n        name: meta.name,\n        type: meta.type,\n        hash: meta.hash,\n        uri,\n        width: meta.width,\n        height: meta.height,\n      });\n\n      // TODO: FileSystem should probably support 'downloading' from drawable\n      // resources But for now it doesn't (it only supports raw resources) and\n      // React Native's Image works fine with drawable resource names for\n      // images.\n      if (Platform.OS === 'android' && !uri.includes(':') && (meta.width || meta.height)) {\n        asset.localUri = asset.uri;\n        asset.downloaded = true;\n      }\n\n      Asset.byHash[meta.hash] = asset;\n      return asset;\n    }\n\n    return Asset.fromMetadata(meta);\n  }\n\n  static fromMetadata(meta: AssetMetadata): Asset {\n    // The hash of the whole asset, not to be confused with the hash of a specific file returned\n    // from `selectAssetSource`\n    const metaHash = meta.hash;\n    if (Asset.byHash[metaHash]) {\n      return Asset.byHash[metaHash];\n    } else if (!IS_MANAGED_ENV && !Asset.byHash[metaHash]) {\n      throw new Error('Assets must be initialized with Asset.fromModule');\n    }\n\n    const { uri, hash } = AssetSources.selectAssetSource(meta);\n    const asset = new Asset({\n      name: meta.name,\n      type: meta.type,\n      hash,\n      uri,\n      width: meta.width,\n      height: meta.height,\n    });\n    Asset.byHash[metaHash] = asset;\n    return asset;\n  }\n\n  static fromURI(uri: string): Asset {\n    if (Asset.byUri[uri]) {\n      return Asset.byUri[uri];\n    }\n\n    // Possibly a Base64-encoded URI\n    let type = '';\n    if (uri.indexOf(';base64') > -1) {\n      type = uri.split(';')[0].split('/')[1];\n    } else {\n      const extension = AssetUris.getFileExtension(uri);\n      type = extension.startsWith('.') ? extension.substring(1) : extension;\n    }\n\n    const asset = new Asset({\n      name: '',\n      type,\n      hash: null,\n      uri,\n    });\n\n    Asset.byUri[uri] = asset;\n\n    return asset;\n  }\n\n  async downloadAsync(): Promise<void> {\n    if (this.downloaded) {\n      return;\n    }\n    if (this.downloading) {\n      await new Promise((resolve, reject) => {\n        this._downloadCallbacks.push({ resolve, reject });\n      });\n      return;\n    }\n    this.downloading = true;\n\n    try {\n      if (Platform.OS === 'web') {\n        if (ImageAssets.isImageType(this.type)) {\n          const { width, height, name } = await ImageAssets.getImageInfoAsync(this.uri);\n          this.width = width;\n          this.height = height;\n          this.name = name;\n        } else {\n          this.name = AssetUris.getFilename(this.uri);\n        }\n      }\n      this.localUri = await downloadAsync(this.uri, this.hash, this.type, this.name);\n\n      this.downloaded = true;\n      this._downloadCallbacks.forEach(({ resolve }) => resolve());\n    } catch (e) {\n      this._downloadCallbacks.forEach(({ reject }) => reject(e));\n      throw e;\n    } finally {\n      this.downloading = false;\n      this._downloadCallbacks = [];\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}