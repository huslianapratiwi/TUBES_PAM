{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nimport React from 'react';\nimport { createAnimatedAlways } from \"./AnimatedAlways\";\nimport AnimatedNode from \"./AnimatedNode\";\nvar Code = function (_React$Component) {\n  _inherits(Code, _React$Component);\n  var _super = _createSuper(Code);\n  function Code() {\n    _classCallCheck(this, Code);\n    return _super.apply(this, arguments);\n  }\n  _createClass(Code, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this$props = this.props,\n        children = _this$props.children,\n        exec = _this$props.exec;\n      var nodeChildren = Code.resolveNode(children);\n      var nodeExec = Code.resolveNode(exec);\n      var cantResolveNode = nodeChildren === null && nodeExec === null;\n      if (cantResolveNode) {\n        var error = nodeChildren === null ? \"Got \\\"\" + typeof children + \"\\\" type passed to children\" : \"Got \\\"\" + typeof exec + \"\\\" type passed to exec\";\n        throw new Error(\"<Animated.Code /> expects the 'exec' prop or children to be an animated node or a function returning an animated node. \" + error);\n      }\n      this.always = createAnimatedAlways(nodeExec || nodeChildren);\n      this.always.__attach();\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.always.__detach();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return null;\n    }\n  }]);\n  return Code;\n}(React.Component);\nCode.resolveNode = function (maybeNode) {\n  if (typeof maybeNode === 'function') {\n    return Code.resolveNode(maybeNode());\n  }\n  if (maybeNode instanceof AnimatedNode) {\n    return maybeNode;\n  }\n  return null;\n};\nexport default Code;","map":{"version":3,"names":["React","createAnimatedAlways","AnimatedNode","Code","props","children","exec","nodeChildren","resolveNode","nodeExec","cantResolveNode","error","Error","always","__attach","__detach","Component","maybeNode"],"sources":["C:/Users/HUSLIANA/react_native_storeapp-master/node_modules/react-native-reanimated/src/core/AnimatedCode.js"],"sourcesContent":["import React from 'react';\nimport { createAnimatedAlways } from './AnimatedAlways';\nimport AnimatedNode from './AnimatedNode';\n\nclass Code extends React.Component {\n  static resolveNode = maybeNode => {\n    if (typeof maybeNode === 'function') {\n      return Code.resolveNode(maybeNode());\n    }\n\n    if (maybeNode instanceof AnimatedNode) {\n      return maybeNode;\n    }\n\n    return null;\n  };\n\n  componentDidMount() {\n    const { children, exec } = this.props;\n    const nodeChildren = Code.resolveNode(children);\n    const nodeExec = Code.resolveNode(exec);\n\n    const cantResolveNode = nodeChildren === null && nodeExec === null;\n\n    if (cantResolveNode) {\n      const error =\n        nodeChildren === null\n          ? `Got \"${typeof children}\" type passed to children`\n          : `Got \"${typeof exec}\" type passed to exec`;\n\n      throw new Error(\n        `<Animated.Code /> expects the 'exec' prop or children to be an animated node or a function returning an animated node. ${error}`\n      );\n    }\n\n    this.always = createAnimatedAlways(nodeExec || nodeChildren);\n    this.always.__attach();\n  }\n\n  componentWillUnmount() {\n    this.always.__detach();\n  }\n\n  render() {\n    return null;\n  }\n}\nexport default Code;\n"],"mappings":";;;;;;;AAAA,OAAOA,KAAK,MAAM,OAAO;AACzB,SAASC,oBAAoB;AAC7B,OAAOC,YAAY;AAAuB,IAEpCC,IAAI;EAAA;EAAA;EAAA;IAAA;IAAA;EAAA;EAAA;IAAA;IAAA,oCAaY;MAAA,kBACS,IAAI,CAACC,KAAK;QAA7BC,QAAQ,eAARA,QAAQ;QAAEC,IAAI,eAAJA,IAAI;MACtB,IAAMC,YAAY,GAAGJ,IAAI,CAACK,WAAW,CAACH,QAAQ,CAAC;MAC/C,IAAMI,QAAQ,GAAGN,IAAI,CAACK,WAAW,CAACF,IAAI,CAAC;MAEvC,IAAMI,eAAe,GAAGH,YAAY,KAAK,IAAI,IAAIE,QAAQ,KAAK,IAAI;MAElE,IAAIC,eAAe,EAAE;QACnB,IAAMC,KAAK,GACTJ,YAAY,KAAK,IAAI,cACT,OAAOF,QAAQ,6CACf,OAAOC,IAAI,2BAAuB;QAEhD,MAAM,IAAIM,KAAK,6HAC6GD,KAAK,CAChI;MACH;MAEA,IAAI,CAACE,MAAM,GAAGZ,oBAAoB,CAACQ,QAAQ,IAAIF,YAAY,CAAC;MAC5D,IAAI,CAACM,MAAM,CAACC,QAAQ,EAAE;IACxB;EAAC;IAAA;IAAA,uCAEsB;MACrB,IAAI,CAACD,MAAM,CAACE,QAAQ,EAAE;IACxB;EAAC;IAAA;IAAA,yBAEQ;MACP,OAAO,IAAI;IACb;EAAC;EAAA;AAAA,EAzCgBf,KAAK,CAACgB,SAAS;AAA5Bb,IAAI,CACDK,WAAW,GAAG,UAAAS,SAAS,EAAI;EAChC,IAAI,OAAOA,SAAS,KAAK,UAAU,EAAE;IACnC,OAAOd,IAAI,CAACK,WAAW,CAACS,SAAS,EAAE,CAAC;EACtC;EAEA,IAAIA,SAAS,YAAYf,YAAY,EAAE;IACrC,OAAOe,SAAS;EAClB;EAEA,OAAO,IAAI;AACb,CAAC;AAgCH,eAAed,IAAI"},"metadata":{},"sourceType":"module"}