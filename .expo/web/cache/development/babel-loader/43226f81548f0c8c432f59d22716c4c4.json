{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport ExpoFontLoader from \"./ExpoFontLoader\";\nexport function fontFamilyNeedsScoping(name) {\n  return false;\n}\nfunction isAsset(asset) {\n  return typeof asset === 'object' && 'uri' in asset && 'name' in asset;\n}\nexport function getAssetForSource(source) {\n  if (isAsset(source)) {\n    return {\n      uri: source.uri || source.localUri\n    };\n  }\n  if (typeof source !== 'string') {\n    throw new Error(\"Unexpected type \" + typeof source + \" expected a URI string or Asset from expo-asset.\");\n  }\n  return {\n    uri: source\n  };\n}\nexport function loadSingleFontAsync(name, input) {\n  var asset;\n  return _regeneratorRuntime.async(function loadSingleFontAsync$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          asset = input;\n          if (!asset.downloadAsync) {\n            _context.next = 3;\n            break;\n          }\n          throw new Error('expo-font: loadSingleFontAsync expected an asset of type FontResource on web');\n        case 3:\n          _context.next = 5;\n          return _regeneratorRuntime.awrap(ExpoFontLoader.loadAsync(name, input));\n        case 5:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function getNativeFontName(name) {\n  return name;\n}","map":{"version":3,"mappings":";AACA,OAAOA,cAAc;AAGrB,OAAM,SAAUC,sBAAsB,CAACC,IAAY;EACjD,OAAO,KAAK;AACd;AAEA,SAASC,OAAO,CAACC,KAAU;EACzB,OAAO,OAAOA,KAAK,KAAK,QAAQ,IAAI,KAAK,IAAIA,KAAK,IAAI,MAAM,IAAIA,KAAK;AACvE;AAEA,OAAM,SAAUC,iBAAiB,CAACC,MAAkB;EAClD,IAAIH,OAAO,CAACG,MAAM,CAAC,EAAE;IACnB,OAAO;MACLC,GAAG,EAAED,MAAM,CAACC,GAAG,IAAID,MAAM,CAACE;KAC3B;;EAGH,IAAI,OAAOF,MAAM,KAAK,QAAQ,EAAE;IAC9B,MAAM,IAAIG,KAAK,sBACM,OAAOH,MAAM,sDACjC;;EAGH,OAAO;IACLC,GAAG,EAAED;GACN;AACH;AAEA,OAAO,SAAeI,mBAAmB,CACvCR,IAAY,EACZS,KAA2B;EAAA;EAAA;IAAA;MAAA;QAAA;UAErBP,KAAK,GAAGO,KAAY;UAAA,KACtBP,KAAK,CAACQ,aAAa;YAAA;YAAA;UAAA;UAAA,MACf,IAAIH,KAAK,CAAC,8EAA8E,CAAC;QAAA;UAAA;UAAA,iCAG3FT,cAAc,CAACa,SAAS,CAACX,IAAI,EAAES,KAAK,CAAC;QAAA;QAAA;UAAA;MAAA;IAAA;EAAA;AAAA;AAG7C,OAAM,SAAUG,iBAAiB,CAACZ,IAAY;EAC5C,OAAOA,IAAI;AACb","names":["ExpoFontLoader","fontFamilyNeedsScoping","name","isAsset","asset","getAssetForSource","source","uri","localUri","Error","loadSingleFontAsync","input","downloadAsync","loadAsync","getNativeFontName"],"sourceRoot":"","sources":["../src/FontLoader.web.ts"],"sourcesContent":["import { Asset } from 'expo-asset';\nimport ExpoFontLoader from './ExpoFontLoader';\nimport { FontSource, FontResource } from './Font.types';\n\nexport function fontFamilyNeedsScoping(name: string): boolean {\n  return false;\n}\n\nfunction isAsset(asset: any): asset is Asset {\n  return typeof asset === 'object' && 'uri' in asset && 'name' in asset;\n}\n\nexport function getAssetForSource(source: FontSource): FontResource {\n  if (isAsset(source)) {\n    return {\n      uri: source.uri || source.localUri!,\n    };\n  }\n\n  if (typeof source !== 'string') {\n    throw new Error(\n      `Unexpected type ${typeof source} expected a URI string or Asset from expo-asset.`\n    );\n  }\n\n  return {\n    uri: source,\n  };\n}\n\nexport async function loadSingleFontAsync(\n  name: string,\n  input: Asset | FontResource\n): Promise<void> {\n  const asset = input as any;\n  if (asset.downloadAsync) {\n    throw new Error('expo-font: loadSingleFontAsync expected an asset of type FontResource on web');\n  }\n\n  await ExpoFontLoader.loadAsync(name, input);\n}\n\nexport function getNativeFontName(name: string): string {\n  return name;\n}\n"]},"metadata":{},"sourceType":"module"}