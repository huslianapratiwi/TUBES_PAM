{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.extractFieldPathData = extractFieldPathData;\nexports.parseUpdateArgs = parseUpdateArgs;\nexports.parseSetOptions = parseSetOptions;\nexports.parseSnapshotArgs = parseSnapshotArgs;\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\nvar _common = require(\"@react-native-firebase/app/lib/common\");\nvar _FirestoreFieldPath = _interopRequireWildcard(require(\"../FirestoreFieldPath\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nfunction extractFieldPathData(data, segmenets) {\n  if (!(0, _common.isObject)(data)) {\n    return undefined;\n  }\n  var pathValue = data[segmenets[0]];\n  if (segmenets.length === 1) {\n    return pathValue;\n  }\n  return extractFieldPathData(pathValue, segmenets.slice(1));\n}\nfunction parseUpdateArgs(args) {\n  var data = {};\n  if (args.length === 1) {\n    if (!(0, _common.isObject)(args[0])) {\n      throw new Error('if using a single update argument, it must be an object.');\n    }\n    var _args = (0, _slicedToArray2.default)(args, 1);\n    data = _args[0];\n  } else if (args.length % 2 === 1) {\n    throw new Error('the update arguments must be either a single object argument, or equal numbers of key/value pairs.');\n  } else {\n    for (var i = 0; i < args.length; i += 2) {\n      var key = args[i];\n      var value = args[i + 1];\n      if ((0, _common.isString)(key)) {\n        data[key] = value;\n      } else if (key instanceof _FirestoreFieldPath.default) {\n        data[key._toPath()] = value;\n      } else {\n        throw new Error(\"argument at index \" + i + \" must be a string or FieldPath\");\n      }\n    }\n  }\n  return data;\n}\nfunction parseSetOptions(options) {\n  var out = {};\n  if ((0, _common.isUndefined)(options)) {\n    return out;\n  }\n  if (!(0, _common.isObject)(options)) {\n    throw new Error(\"'options' must be an object.\");\n  }\n  if ((0, _common.hasOwnProperty)(options, 'merge') && (0, _common.hasOwnProperty)(options, 'mergeFields')) {\n    throw new Error(\"'options' must not contain both 'merge' & 'mergeFields'.\");\n  }\n  if (!(0, _common.isUndefined)(options.merge)) {\n    if (!(0, _common.isBoolean)(options.merge)) {\n      throw new Error(\"'options.merge' must be a boolean value.\");\n    }\n    out.merge = true;\n  }\n  if (!(0, _common.isUndefined)(options.mergeFields)) {\n    if (!(0, _common.isArray)(options.mergeFields)) {\n      throw new Error(\"'options.mergeFields' must be an array.\");\n    }\n    out.mergeFields = [];\n    for (var i = 0; i < options.mergeFields.length; i++) {\n      var field = options.mergeFields[i];\n      if (!(0, _common.isString)(field) && !(field instanceof _FirestoreFieldPath.default)) {\n        throw new Error(\"'options.mergeFields' all fields must be of type string or FieldPath, but the value at index \" + i + \" was \" + typeof field);\n      }\n      var path = field;\n      if ((0, _common.isString)(path)) {\n        try {\n          path = (0, _FirestoreFieldPath.fromDotSeparatedString)(field);\n        } catch (e) {\n          throw new Error(\"'options.mergeFields' \" + e.message);\n        }\n      }\n      if (field instanceof _FirestoreFieldPath.default) {\n        out.mergeFields.push(field._toPath());\n      } else {\n        out.mergeFields.push(field);\n      }\n    }\n  }\n  return out;\n}\nfunction isPartialObserver(input) {\n  if (input == null) {\n    return false;\n  }\n  return input.next != null || input.error != null || input.complete != null;\n}\nfunction parseSnapshotArgs(args) {\n  if (args.length === 0) {\n    throw new Error('expected at least one argument.');\n  }\n  var NOOP = function NOOP() {};\n  var snapshotListenOptions = {};\n  var callback = NOOP;\n  var onError = NOOP;\n  var onNext = NOOP;\n  if ((0, _common.isFunction)(args[0])) {\n    if ((0, _common.isFunction)(args[1])) {\n      onNext = args[0];\n      onError = args[1];\n    } else {\n      callback = args[0];\n    }\n  }\n  if ((0, _common.isObject)(args[0]) && isPartialObserver(args[0])) {\n    var observer = args[0];\n    if (observer.error) {\n      onError = (0, _common.isFunction)(observer.error) ? observer.error.bind(observer) : observer.error;\n    }\n    if (observer.next) {\n      onNext = (0, _common.isFunction)(observer.next) ? observer.next.bind(observer) : observer.next;\n    }\n  }\n  if ((0, _common.isObject)(args[0]) && !isPartialObserver(args[0])) {\n    snapshotListenOptions.includeMetadataChanges = args[0].includeMetadataChanges == null ? false : args[0].includeMetadataChanges;\n    if ((0, _common.isFunction)(args[1])) {\n      if ((0, _common.isFunction)(args[2])) {\n        onNext = args[1];\n        onError = args[2];\n      } else {\n        callback = args[1];\n      }\n    } else if (isPartialObserver(args[1])) {\n      var _observer = args[1];\n      if (_observer.error) {\n        onError = (0, _common.isFunction)(_observer.error) ? _observer.error.bind(_observer) : _observer.error;\n      }\n      if (_observer.next) {\n        onNext = (0, _common.isFunction)(_observer.next) ? _observer.next.bind(_observer) : _observer.next;\n      }\n    }\n  }\n  if ((0, _common.hasOwnProperty)(snapshotListenOptions, 'includeMetadataChanges')) {\n    if (!(0, _common.isBoolean)(snapshotListenOptions.includeMetadataChanges)) {\n      throw new Error(\"'options' SnapshotOptions.includeMetadataChanges must be a boolean value.\");\n    }\n  }\n  if (!(0, _common.isFunction)(onNext)) {\n    throw new Error(\"'observer.next' or 'onNext' expected a function.\");\n  }\n  if (!(0, _common.isFunction)(onError)) {\n    throw new Error(\"'observer.error' or 'onError' expected a function.\");\n  }\n  return {\n    snapshotListenOptions: snapshotListenOptions,\n    callback: callback,\n    onNext: onNext,\n    onError: onError\n  };\n}","map":{"version":3,"names":["extractFieldPathData","data","segmenets","isObject","undefined","pathValue","length","slice","parseUpdateArgs","args","Error","i","key","value","isString","FirestoreFieldPath","_toPath","parseSetOptions","options","out","isUndefined","hasOwnProperty","merge","isBoolean","mergeFields","isArray","field","path","fromDotSeparatedString","e","message","push","isPartialObserver","input","next","error","complete","parseSnapshotArgs","NOOP","snapshotListenOptions","callback","onError","onNext","isFunction","observer","bind","includeMetadataChanges"],"sources":["C:/Users/HUSLIANA/react-native-ecommerce/node_modules/@react-native-firebase/firestore/lib/utils/index.js"],"sourcesContent":["/*\n * Copyright (c) 2016-present Invertase Limited & Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this library except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport {\n  hasOwnProperty,\n  isArray,\n  isBoolean,\n  isFunction,\n  isObject,\n  isString,\n  isUndefined,\n} from '@react-native-firebase/app/lib/common';\nimport FirestoreFieldPath, { fromDotSeparatedString } from '../FirestoreFieldPath';\n\nexport function extractFieldPathData(data, segmenets) {\n  if (!isObject(data)) {\n    return undefined;\n  }\n\n  const pathValue = data[segmenets[0]];\n\n  if (segmenets.length === 1) {\n    return pathValue;\n  }\n\n  return extractFieldPathData(pathValue, segmenets.slice(1));\n}\n\nexport function parseUpdateArgs(args) {\n  let data = {};\n  if (args.length === 1) {\n    if (!isObject(args[0])) {\n      throw new Error('if using a single update argument, it must be an object.');\n    }\n    [data] = args;\n  } else if (args.length % 2 === 1) {\n    throw new Error(\n      'the update arguments must be either a single object argument, or equal numbers of key/value pairs.',\n    );\n  } else {\n    for (let i = 0; i < args.length; i += 2) {\n      const key = args[i];\n      const value = args[i + 1];\n      if (isString(key)) {\n        data[key] = value;\n      } else if (key instanceof FirestoreFieldPath) {\n        data[key._toPath()] = value;\n      } else {\n        throw new Error(`argument at index ${i} must be a string or FieldPath`);\n      }\n    }\n  }\n  return data;\n}\n\n/**\n *\n * @param options\n */\nexport function parseSetOptions(options) {\n  const out = {};\n\n  if (isUndefined(options)) {\n    return out;\n  }\n\n  if (!isObject(options)) {\n    throw new Error(\"'options' must be an object.\");\n  }\n\n  if (hasOwnProperty(options, 'merge') && hasOwnProperty(options, 'mergeFields')) {\n    throw new Error(\"'options' must not contain both 'merge' & 'mergeFields'.\");\n  }\n\n  if (!isUndefined(options.merge)) {\n    if (!isBoolean(options.merge)) {\n      throw new Error(\"'options.merge' must be a boolean value.\");\n    }\n\n    out.merge = true;\n  }\n\n  if (!isUndefined(options.mergeFields)) {\n    if (!isArray(options.mergeFields)) {\n      throw new Error(\"'options.mergeFields' must be an array.\");\n    }\n\n    out.mergeFields = [];\n\n    for (let i = 0; i < options.mergeFields.length; i++) {\n      const field = options.mergeFields[i];\n      if (!isString(field) && !(field instanceof FirestoreFieldPath)) {\n        throw new Error(\n          `'options.mergeFields' all fields must be of type string or FieldPath, but the value at index ${i} was ${typeof field}`,\n        );\n      }\n\n      let path = field;\n\n      if (isString(path)) {\n        try {\n          path = fromDotSeparatedString(field);\n        } catch (e) {\n          throw new Error(`'options.mergeFields' ${e.message}`);\n        }\n      }\n\n      if (field instanceof FirestoreFieldPath) {\n        out.mergeFields.push(field._toPath());\n      } else {\n        out.mergeFields.push(field);\n      }\n    }\n  }\n\n  return out;\n}\n\n// function buildFieldPathData(segments, value) {\n//   if (segments.length === 1) {\n//     return {\n//       [segments[0]]: value,\n//     };\n//   }\n//   return {\n//     [segments[0]]: buildFieldPathData(segments.slice(1), value),\n//   };\n// }\n\nfunction isPartialObserver(input) {\n  if (input == null) {\n    return false;\n  }\n  return input.next != null || input.error != null || input.complete != null;\n}\n\nexport function parseSnapshotArgs(args) {\n  if (args.length === 0) {\n    throw new Error('expected at least one argument.');\n  }\n\n  // Ignore onComplete as its never used\n  const NOOP = () => {};\n  const snapshotListenOptions = {};\n  let callback = NOOP;\n  let onError = NOOP;\n  let onNext = NOOP;\n\n  /**\n   * .onSnapshot(Function...\n   */\n  if (isFunction(args[0])) {\n    /**\n     * .onSnapshot((snapshot) => {}, (error) => {}\n     */\n    if (isFunction(args[1])) {\n      onNext = args[0];\n      onError = args[1];\n    } else {\n      /**\n       * .onSnapshot((snapshot, error) => {})\n       */\n      callback = args[0];\n    }\n  }\n\n  /**\n   * .onSnapshot({ complete: () => {}, error: (e) => {}, next: (snapshot) => {} })\n   */\n  if (isObject(args[0]) && isPartialObserver(args[0])) {\n    const observer = args[0];\n    if (observer.error) {\n      onError = isFunction(observer.error) ? observer.error.bind(observer) : observer.error;\n    }\n    if (observer.next) {\n      onNext = isFunction(observer.next) ? observer.next.bind(observer) : observer.next;\n    }\n  }\n\n  /**\n   * .onSnapshot(SnapshotListenOptions, ...\n   */\n  if (isObject(args[0]) && !isPartialObserver(args[0])) {\n    snapshotListenOptions.includeMetadataChanges =\n      args[0].includeMetadataChanges == null ? false : args[0].includeMetadataChanges;\n    if (isFunction(args[1])) {\n      /**\n       * .onSnapshot(SnapshotListenOptions, Function);\n       */\n      if (isFunction(args[2])) {\n        /**\n         * .onSnapshot(SnapshotListenOptions, (snapshot) => {}, (error) => {});\n         */\n        onNext = args[1];\n        onError = args[2];\n      } else {\n        /**\n         * .onSnapshot(SnapshotListenOptions, (s, e) => {};\n         */\n        callback = args[1];\n      }\n    } else if (isPartialObserver(args[1])) {\n      /**\n       * .onSnapshot(SnapshotListenOptions, { complete: () => {}, error: (e) => {}, next: (snapshot) => {} });\n       */\n      const observer = args[1];\n      if (observer.error) {\n        onError = isFunction(observer.error) ? observer.error.bind(observer) : observer.error;\n      }\n      if (observer.next) {\n        onNext = isFunction(observer.next) ? observer.next.bind(observer) : observer.next;\n      }\n    }\n  }\n\n  if (hasOwnProperty(snapshotListenOptions, 'includeMetadataChanges')) {\n    if (!isBoolean(snapshotListenOptions.includeMetadataChanges)) {\n      throw new Error(\"'options' SnapshotOptions.includeMetadataChanges must be a boolean value.\");\n    }\n  }\n\n  if (!isFunction(onNext)) {\n    throw new Error(\"'observer.next' or 'onNext' expected a function.\");\n  }\n\n  if (!isFunction(onError)) {\n    throw new Error(\"'observer.error' or 'onError' expected a function.\");\n  }\n\n  return { snapshotListenOptions, callback, onNext, onError };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}